#cloud-config
# Go-MySQL Jump Host - Secure Configuration
# This instance serves as both the Go-MySQL API server and jump host

# Set hostname with private FQDN
hostname: go-mysql-jump-host
fqdn: go-mysql-jump-host.internal.${domain_name}

# Update system
package_update: true
package_upgrade: true

# Install required packages
packages:
  - curl
  - wget
  - git
  - htop
  - vim
  - fail2ban
  - ufw
  - mysql-client
  - golang
  - build-essential
  - createrepo
  - yum-utils
  - httpd
  - nginx

# Create users
users:
  - name: admin
    groups: [sudo, docker]
    shell: /bin/bash
    sudo: ALL=(ALL) NOPASSWD:ALL
    ssh_authorized_keys:
      - ${ssh_public_key}
  - name: go-mysql
    groups: [docker]
    shell: /bin/bash
    home: /opt/go-mysql
    create_home: true

# Write files
write_files:
  # IMDSv2 enforcement script
  - path: /tmp/imdsv2-local.sh
    content: |
      #!/bin/bash
      # Local IMDSv2 Enforcement Script - Embedded in CloudInit
      # This script enforces IMDSv2 token authentication locally
      
      set -euo pipefail
      
      # Colors for output
      RED='\033[0;31m'
      GREEN='\033[0;32m'
      YELLOW='\033[1;33m'
      BLUE='\033[0;34m'
      NC='\033[0m' # No Color
      
      log() {
          echo -e "${GREEN}[$(date +'%Y-%m-%d %H:%M:%S')] $1${NC}" | tee -a /var/log/imdsv2-enforcement.log
      }
      
      error() {
          echo -e "${RED}[ERROR] $1${NC}" | tee -a /var/log/imdsv2-enforcement.log
      }
      
      # Create secure directory
      SECURE_DIR="/opt/imdsv2"
      mkdir -p "$SECURE_DIR"
      chmod 700 "$SECURE_DIR"
      chown root:root "$SECURE_DIR"
      
      log "Starting local IMDSv2 enforcement setup..."
      
      # Function to create iptables rules that block ALL direct metadata access
      create_metadata_blocking_rules() {
          log "Creating iptables rules to block direct metadata access..."
          
          # Create the blocking script
          cat > "$SECURE_DIR/block-metadata.sh" << 'EOF'
      #!/bin/bash
      # Block ALL direct metadata access - Force IMDSv2 token authentication
      
      # Metadata service IP and port
      METADATA_IP="169.254.169.254"
      METADATA_PORT="80"
      
      # Flush any existing rules for metadata service
      iptables -D OUTPUT -d $METADATA_IP -p tcp --dport $METADATA_PORT -j ACCEPT 2>/dev/null || true
      iptables -D OUTPUT -d $METADATA_IP -p tcp --dport $METADATA_PORT -j DROP 2>/dev/null || true
      iptables -D OUTPUT -d $METADATA_IP -p tcp --dport $METADATA_PORT -j LOG 2>/dev/null || true
      
      # Block ALL direct access to metadata service
      # This forces applications to use IMDSv2 tokens
      iptables -A OUTPUT -d $METADATA_IP -p tcp --dport $METADATA_PORT -j DROP
      
      # Allow ONLY token endpoint access (PUT requests to /latest/api/token)
      # This allows getting IMDSv2 tokens but blocks everything else
      iptables -A OUTPUT -d $METADATA_IP -p tcp --dport $METADATA_PORT \
          -m string --string "PUT" --algo bm \
          -m string --string "/latest/api/token" --algo bm \
          -j ACCEPT
      
      # Log all blocked attempts for monitoring
      iptables -A OUTPUT -d $METADATA_IP -p tcp --dport $METADATA_PORT \
          -j LOG --log-prefix "BLOCKED_METADATA_ACCESS: " --log-level 4
      
      # Save rules to persist across reboots
      mkdir -p /etc/iptables
      iptables-save > /etc/iptables/rules.v4
      
      echo "Metadata access blocking rules applied successfully"
      EOF
      
          chmod +x "$SECURE_DIR/block-metadata.sh"
          
          # Run the blocking script
          "$SECURE_DIR/block-metadata.sh"
          
          log "Direct metadata access blocked - only token-based access allowed"
      }
      
      # Function to create secure metadata access wrapper
      create_secure_wrapper() {
          log "Creating secure metadata access wrapper..."
          
          cat > "$SECURE_DIR/secure-metadata" << 'EOF'
      #!/bin/bash
      # Secure metadata access wrapper - REQUIRES IMDSv2 tokens
      
      set -euo pipefail
      
      METADATA_BASE="http://169.254.169.254/latest"
      TOKEN_TTL="21600"  # 6 hours
      
      # Function to get IMDSv2 token
      get_token() {
          local token
          token=$(curl -s -X PUT "$METADATA_BASE/api/token" \
              -H "X-aws-ec2-metadata-token-ttl-seconds: $TOKEN_TTL" \
              --max-time 10)
          
          if [[ -z "$token" ]]; then
              echo "ERROR: Failed to obtain IMDSv2 token" >&2
              exit 1
          fi
          
          echo "$token"
      }
      
      # Function to make secure metadata request
      secure_request() {
          local path="$1"
          local token="$2"
          
          curl -s -H "X-aws-ec2-metadata-token: $token" \
              "$METADATA_BASE/meta-data/$path" \
              --max-time 10
      }
      
      # Main function
      main() {
          if [[ $# -eq 0 ]]; then
              echo "Usage: $0 <metadata-path>"
              echo "Example: $0 instance-id"
              echo "Example: $0 iam/security-credentials/"
              exit 1
          fi
          
          local path="$1"
          local token
          
          # Get fresh token
          token=$(get_token)
          
          # Make secure request
          secure_request "$path" "$token"
      }
      
      main "$@"
      EOF
      
          chmod +x "$SECURE_DIR/secure-metadata"
          chown root:root "$SECURE_DIR/secure-metadata"
          
          # Create symlink for easy access
          ln -sf "$SECURE_DIR/secure-metadata" /usr/local/bin/secure-metadata
          
          log "Secure metadata wrapper created at /usr/local/bin/secure-metadata"
      }
      
      # Function to create systemd service for persistent enforcement
      create_systemd_service() {
          log "Creating systemd service for persistent enforcement..."
          
          cat > /etc/systemd/system/imdsv2-enforcement.service << EOF
      [Unit]
      Description=IMDSv2 Enforcement Service
      After=network.target
      Wants=network.target
      
      [Service]
      Type=oneshot
      ExecStart=$SECURE_DIR/block-metadata.sh
      RemainAfterExit=yes
      User=root
      
      [Install]
      WantedBy=multi-user.target
      EOF
      
          systemctl daemon-reload
          systemctl enable imdsv2-enforcement.service
          systemctl start imdsv2-enforcement.service
          
          log "IMDSv2 enforcement service created and started"
      }
      
      # Function to test the enforcement
      test_enforcement() {
          log "Testing IMDSv2 enforcement..."
          
          # Test 1: Direct access should be blocked
          if curl -s --max-time 5 "http://169.254.169.254/latest/meta-data/instance-id" > /dev/null 2>&1; then
              error "FAILED: Direct metadata access is still allowed!"
              return 1
          else
              log "✓ Direct metadata access is blocked"
          fi
          
          # Test 2: Secure wrapper should work
          local instance_id
          instance_id=$(secure-metadata "instance-id" 2>/dev/null || echo "")
          
          if [[ -n "$instance_id" ]]; then
              log "✓ Secure metadata access works: $instance_id"
          else
              error "FAILED: Secure metadata access is not working!"
              return 1
          fi
          
          # Test 3: Token endpoint should work
          local token
          token=$(curl -s -X PUT "http://169.254.169.254/latest/api/token" \
              -H "X-aws-ec2-metadata-token-ttl-seconds: 21600" \
              --max-time 5)
          
          if [[ -n "$token" ]]; then
              log "✓ Token endpoint is accessible"
          else
              error "FAILED: Token endpoint is not accessible!"
              return 1
          fi
          
          log "All IMDSv2 enforcement tests passed!"
      }
      
      # Main execution
      main() {
          log "Setting up local IMDSv2 enforcement..."
          
          # Create blocking rules
          create_metadata_blocking_rules
          
          # Create secure wrapper
          create_secure_wrapper
          
          # Create systemd service
          create_systemd_service
          
          # Test enforcement
          test_enforcement
          
          log "Local IMDSv2 enforcement setup completed successfully!"
          log ""
          log "IMPORTANT: Direct metadata access is now BLOCKED"
          log "Use 'secure-metadata <path>' for secure access"
          log "Example: secure-metadata instance-id"
          log "Example: secure-metadata iam/security-credentials/"
          log ""
          log "Monitoring logs: /var/log/messages"
          log "Enforcement logs: /var/log/imdsv2-enforcement.log"
      }
      
      # Run main function
      main "$@"
    permissions: '0755'
    owner: root:root

  # SSH configuration
  - path: /etc/ssh/sshd_config
    content: |
      Port 22
      Protocol 2
      HostKey /etc/ssh/ssh_host_rsa_key
      HostKey /etc/ssh/ssh_host_ecdsa_key
      HostKey /etc/ssh/ssh_host_ed25519_key
      UsePrivilegeSeparation yes
      KeyRegenerationInterval 3600
      ServerKeyBits 2048
      SyslogFacility AUTH
      LogLevel INFO
      LoginGraceTime 120
      PermitRootLogin no
      StrictModes yes
      RSAAuthentication yes
      PubkeyAuthentication yes
      IgnoreRhosts yes
      RhostsRSAAuthentication no
      HostbasedAuthentication no
      PermitEmptyPasswords no
      ChallengeResponseAuthentication no
      PasswordAuthentication no
      X11Forwarding no
      X11DisplayOffset 10
      PrintMotd no
      PrintLastLog yes
      TCPKeepAlive yes
      AcceptEnv LANG LC_*
      Subsystem sftp /usr/lib/openssh/sftp-server
      UsePAM yes
      ClientAliveInterval 300
      ClientAliveCountMax 2
      MaxAuthTries 3
      MaxSessions 10
    permissions: '0644'
    owner: root:root

  # UFW firewall configuration
  - path: /etc/ufw/before.rules
    content: |
      # Allow loopback
      -A ufw-before-input -i lo -j ACCEPT
      -A ufw-before-output -o lo -j ACCEPT
      
      # Allow established and related connections
      -A ufw-before-input -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT
      -A ufw-before-output -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT
      
      # Allow VPC internal traffic
      -A ufw-before-input -s 172.16.0.0/16 -j ACCEPT
      -A ufw-before-input -s 10.100.0.0/24 -j ACCEPT
      -A ufw-before-input -s 10.200.0.0/24 -j ACCEPT
      -A ufw-before-input -s 10.150.0.0/24 -j ACCEPT
      
      # Drop all other traffic
      -A ufw-before-input -j DROP
    permissions: '0644'
    owner: root:root

  # Fail2ban configuration
  - path: /etc/fail2ban/jail.local
    content: |
      [DEFAULT]
      bantime = 3600
      findtime = 600
      maxretry = 3
      backend = systemd
      
      [sshd]
      enabled = true
      port = ssh
      filter = sshd
      logpath = /var/log/auth.log
      maxretry = 3
      bantime = 3600
    permissions: '0644'
    owner: root:root

  # Go-MySQL API service
  - path: /opt/go-mysql/main.go
    content: |
      package main
      
      import (
          "database/sql"
          "fmt"
          "log"
          "net/http"
          "os"
          
          _ "github.com/go-sql-driver/mysql"
      )
      
      func main() {
          // Database connection
          dbHost := os.Getenv("DB_HOST")
          if dbHost == "" {
              dbHost = "localhost"
          }
          
          db, err := sql.Open("mysql", "root:password@tcp("+dbHost+":3306)/testdb")
          if err != nil {
              log.Fatal(err)
          }
          defer db.Close()
          
          // HTTP handler
          http.HandleFunc("/", func(w http.ResponseWriter, r *http.Request) {
              fmt.Fprintf(w, "Go-MySQL API is running!\n")
              fmt.Fprintf(w, "Environment: ${environment}\n")
              fmt.Fprintf(w, "Service: ${service_name}\n")
              fmt.Fprintf(w, "Hostname: go-mysql-jump-host.${domain_name}\n")
          })
          
          http.HandleFunc("/health", func(w http.ResponseWriter, r *http.Request) {
              w.WriteHeader(http.StatusOK)
              fmt.Fprintf(w, "OK")
          })
          
          log.Println("Starting Go-MySQL API server on :8080")
          log.Fatal(http.ListenAndServe(":8080", nil))
      }
    permissions: '0644'
    owner: go-mysql:go-mysql

  # Systemd service for Go-MySQL API
  - path: /etc/systemd/system/go-mysql-api.service
    content: |
      [Unit]
      Description=Go-MySQL API Server
      After=network.target
      
      [Service]
      Type=simple
      User=go-mysql
      WorkingDirectory=/opt/go-mysql
      ExecStart=/usr/local/bin/go run main.go
      Restart=always
      RestartSec=5
      Environment=DB_HOST=localhost
      
      [Install]
      WantedBy=multi-user.target
    permissions: '0644'
    owner: root:root

# Run commands
runcmd:
  # Enable and configure firewall
  - ufw --force enable
  - ufw default deny incoming
  - ufw default allow outgoing
  - ufw allow 22/tcp
  - ufw allow 8080/tcp
  - ufw allow from 172.16.0.0/16
  - ufw allow from 10.100.0.0/24
  - ufw allow from 10.200.0.0/24
  - ufw allow from 10.150.0.0/24

  # Configure fail2ban
  - systemctl enable fail2ban
  - systemctl start fail2ban

  # Install Go
  - wget https://go.dev/dl/go1.21.0.linux-amd64.tar.gz
  - tar -C /usr/local -xzf go1.21.0.linux-amd64.tar.gz
  - echo 'export PATH=$PATH:/usr/local/go/bin' >> /etc/profile
  - echo 'export PATH=$PATH:/usr/local/go/bin' >> /home/go-mysql/.bashrc

  # Install Go dependencies
  - su - go-mysql -c "go mod init go-mysql-api"
  - su - go-mysql -c "go get github.com/go-sql-driver/mysql"

  # Enable and start Go-MySQL API service
  - systemctl daemon-reload
  - systemctl enable go-mysql-api
  - systemctl start go-mysql-api

  # Create SSH config for easy access to other instances
  - mkdir -p /home/admin/.ssh
  - echo "Host kubernetes" >> /home/admin/.ssh/config
  - echo "  HostName ${kubernetes_private_ip}" >> /home/admin/.ssh/config
  - echo "  User admin" >> /home/admin/.ssh/config
  - echo "  Port 22" >> /home/admin/.ssh/config
  - echo "  StrictHostKeyChecking no" >> /home/admin/.ssh/config
  - echo "" >> /home/admin/.ssh/config
  - echo "Host vpn" >> /home/admin/.ssh/config
  - echo "  HostName ${vpn_private_ip}" >> /home/admin/.ssh/config
  - echo "  User admin" >> /home/admin/.ssh/config
  - echo "  Port 22" >> /home/admin/.ssh/config
  - echo "  StrictHostKeyChecking no" >> /home/admin/.ssh/config
  - chown -R admin:admin /home/admin/.ssh
  - chmod 700 /home/admin/.ssh
  - chmod 600 /home/admin/.ssh/config

  # Set hostname
  - hostnamectl set-hostname go-mysql-jump-host.${domain_name}

  # Update /etc/hosts
  - echo "127.0.0.1 go-mysql-jump-host.${domain_name} go-mysql-jump-host" >> /etc/hosts
  - echo "${kubernetes_private_ip} kubernetes-control-plane.${domain_name} kubernetes" >> /etc/hosts
  - echo "${vpn_private_ip} wireguard-vpn-server.${domain_name} vpn" >> /etc/hosts

  # Restart SSH service
  - systemctl restart ssh

  # Set up private package repositories
- mkdir -p /var/www/html/repos/centos/7/x86_64
- mkdir -p /var/www/html/repos/ubuntu/dists/focal/main/binary-amd64
- mkdir -p /var/www/html/repos/ubuntu/dists/focal/universe/binary-amd64

# Configure Apache for repository serving
- systemctl enable httpd
- systemctl start httpd

# Install IMDSv2 enforcement script locally
- cp /tmp/imdsv2-local.sh /opt/enforce-imdsv2.sh 2>/dev/null || echo "Creating local IMDSv2 enforcement script"
- chmod +x /opt/enforce-imdsv2.sh
  
  # Create repository configuration
  - echo "[local-repo]" > /etc/yum.repos.d/local.repo
  - echo "name=Local Repository" >> /etc/yum.repos.d/local.repo
  - echo "baseurl=http://localhost/repos/centos/7/x86_64" >> /etc/yum.repos.d/local.repo
  - echo "enabled=1" >> /etc/yum.repos.d/local.repo
  - echo "gpgcheck=0" >> /etc/yum.repos.d/local.repo
  
  # Create Ubuntu repository configuration
  - echo "deb http://localhost/repos/ubuntu focal main universe" > /etc/apt/sources.list.d/local.list
  - echo "deb http://localhost/repos/ubuntu focal-updates main universe" >> /etc/apt/sources.list.d/local.list
  
  # Download essential packages for repository
  - yum install -y --downloadonly --downloaddir=/var/www/html/repos/centos/7/x86_64 curl wget git htop vim fail2ban ufw mysql-client golang build-essential
  
  # Create repository metadata
  - createrepo /var/www/html/repos/centos/7/x86_64
  
  # Set proper permissions
  - chown -R apache:apache /var/www/html/repos
  - chmod -R 755 /var/www/html/repos
  
  # Enforce IMDSv2 security
- /opt/enforce-imdsv2.sh

# Log completion
- echo "Go-MySQL Jump Host setup completed at $(date)" >> /var/log/cloud-init-output.log
- echo "Private package repositories configured at http://localhost/repos/" >> /var/log/cloud-init-output.log
- echo "IMDSv2 enforcement enabled - direct metadata access blocked" >> /var/log/cloud-init-output.log

# Configure DHCP and DNS for private FQDN resolution
runcmd:
  # Configure DHCP client for private FQDN
  - echo "domain internal.${domain_name}" >> /etc/dhcp/dhclient.conf
  - echo "search internal.${domain_name} ${domain_name}" >> /etc/dhcp/dhclient.conf
  - echo "prepend domain-name-servers 169.254.169.253;" >> /etc/dhcp/dhclient.conf
  
  # Configure resolv.conf for private FQDN resolution
  - echo "domain internal.${domain_name}" > /etc/resolv.conf
  - echo "search internal.${domain_name} ${domain_name}" >> /etc/resolv.conf
  - echo "nameserver 169.254.169.253" >> /etc/resolv.conf
  - echo "nameserver 8.8.8.8" >> /etc/resolv.conf
  - echo "nameserver 8.8.4.4" >> /etc/resolv.conf
  
  # Make resolv.conf immutable to prevent DHCP from overwriting
  - chattr +i /etc/resolv.conf
  
  # Restart networking to apply DHCP changes
  - systemctl restart networking
  
  # Test DNS resolution
  - nslookup go-mysql-jump-host.internal.${domain_name}
  - nslookup mysql.internal.${domain_name}
  - nslookup k8s-api.internal.${domain_name}

# Final message
final_message: "Go-MySQL Jump Host setup completed! Access via VPN to ${vpn_private_ip} then SSH to this instance. Private FQDN: go-mysql-jump-host.internal.${domain_name}"
