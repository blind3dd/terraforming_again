name: ğŸ”’ Automated CVE Detection and Remediation

on:
  schedule:
    # Run daily at 2 AM UTC
    - cron: '0 2 * * *'
  push:
    branches: [ main, develop ]
    paths:
      - '**/go.mod'
      - '**/go.sum'
      - '**/requirements.txt'
      - '**/Pipfile'
      - '**/Pipfile.lock'
      - '**/Dockerfile*'
      - '**/package.json'
      - '**/package-lock.json'
  pull_request:
    paths:
      - '**/go.mod'
      - '**/go.sum'
      - '**/requirements.txt'
      - '**/Pipfile'
      - '**/Pipfile.lock'
      - '**/Dockerfile*'
      - '**/package.json'
      - '**/package-lock.json'
  workflow_dispatch:
    inputs:
      force_remediation:
        description: 'Force remediation even if no CVEs found'
        required: false
        default: 'false'
        type: boolean
  repository_dispatch:
    types: [security-alert, cve-detected]

env:
  TRIVY_VERSION: "0.66.0"
  GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

jobs:
  detect-cves:
    name: ğŸ” Detect CVEs
    runs-on: ubuntu-latest
    outputs:
      cves-found: ${{ steps.detect.outputs.cves-found }}
      cve-count: ${{ steps.detect.outputs.cve-count }}
      cve-details: ${{ steps.detect.outputs.cve-details }}
    
    steps:
    - name: ğŸ“¥ Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0
        token: ${{ secrets.GITHUB_TOKEN }}

    - name: ğŸ”§ Setup Trivy
      uses: aquasecurity/trivy-action@master
      with:
        scan-type: 'fs'
        scan-ref: '.'
        format: 'json'
        output: 'trivy-results.json'

    - name: ğŸ” Detect CVEs
      id: detect
      run: |
        echo "ğŸ” Analyzing Trivy results for CVEs..."
        
        # Parse Trivy results
        if [ -f "trivy-results.json" ]; then
          # Count HIGH and CRITICAL vulnerabilities
          CRITICAL_COUNT=$(jq '[.Results[]?.Vulnerabilities[]? | select(.Severity == "CRITICAL")] | length' trivy-results.json)
          HIGH_COUNT=$(jq '[.Results[]?.Vulnerabilities[]? | select(.Severity == "HIGH")] | length' trivy-results.json)
          TOTAL_CVES=$((CRITICAL_COUNT + HIGH_COUNT))
          
          echo "ğŸ“Š CVE Summary:"
          echo "  Critical: $CRITICAL_COUNT"
          echo "  High: $HIGH_COUNT"
          echo "  Total: $TOTAL_CVES"
          
          if [ "$TOTAL_CVES" -gt 0 ]; then
            echo "cves-found=true" >> $GITHUB_OUTPUT
            echo "cve-count=$TOTAL_CVES" >> $GITHUB_OUTPUT
            
            # Extract CVE details
            CVE_DETAILS=$(jq -r '.Results[]?.Vulnerabilities[]? | select(.Severity == "CRITICAL" or .Severity == "HIGH") | "\(.VulnerabilityID): \(.Title) (Severity: \(.Severity))"' trivy-results.json | head -10)
            echo "cve-details<<EOF" >> $GITHUB_OUTPUT
            echo "$CVE_DETAILS" >> $GITHUB_OUTPUT
            echo "EOF" >> $GITHUB_OUTPUT
            
            echo "ğŸš¨ CVEs detected! Proceeding with remediation..."
          else
            echo "cves-found=false" >> $GITHUB_OUTPUT
            echo "cve-count=0" >> $GITHUB_OUTPUT
            echo "âœ… No HIGH or CRITICAL CVEs found"
          fi
        else
          echo "cves-found=false" >> $GITHUB_OUTPUT
          echo "cve-count=0" >> $GITHUB_OUTPUT
          echo "âš ï¸ No Trivy results found"
        fi

    - name: ğŸ“‹ Upload CVE Report
      uses: actions/upload-artifact@v4
      if: always()
      with:
        name: cve-report
        path: trivy-results.json
        retention-days: 30

  remediate-cves:
    name: ğŸ”§ Auto-Remediate CVEs
    runs-on: ubuntu-latest
    needs: detect-cves
    if: needs.detect-cves.outputs.cves-found == 'true' || github.event.inputs.force_remediation == 'true'
    
    steps:
    - name: ğŸ“¥ Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0
        token: ${{ secrets.GITHUB_TOKEN }}

    - name: ğŸ”§ Setup Go
      uses: actions/setup-go@v4
      with:
        go-version: '1.21.5'

    - name: ğŸ Setup Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.11'

    - name: ğŸ”§ Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '20'

    - name: ğŸ”§ Install pipenv
      run: |
        pip install pipenv
        pipenv --version

    - name: ğŸ”§ Install Trivy
      run: |
        sudo apt-get update
        sudo apt-get install wget apt-transport-https gnupg lsb-release
        wget -qO - https://aquasecurity.github.io/trivy-repo/deb/public.key | sudo apt-key add -
        echo "deb https://aquasecurity.github.io/trivy-repo/deb $(lsb_release -sc) main" | sudo tee -a /etc/apt/sources.list.d/trivy.list
        sudo apt-get update
        sudo apt-get install trivy

    - name: ğŸ”§ Auto-Remediate Go Dependencies
      run: |
        echo "ğŸ“¦ Remediating Go dependencies..."
        
        # Update main go.mod
        if [ -f "go.mod" ]; then
          echo "Updating main go.mod..."
          go get -u ./...
          go get -u github.com/go-sql-driver/mysql@latest
          go get -u github.com/gorilla/mux@latest
          go get -u github.com/stretchr/testify@latest
          go get -u github.com/caarlos0/env@latest
          go get -u gopkg.in/yaml.v3@latest
          go mod tidy
          go mod verify
        fi
        
        # Update application go.mod files
        find . -name "go.mod" -type f | while read gomod; do
          if [ "$gomod" != "./go.mod" ]; then
            echo "Updating $gomod..."
            cd "$(dirname "$gomod")"
            go get -u ./...
            go get -u github.com/go-sql-driver/mysql@latest
            go get -u github.com/gorilla/mux@latest
            go get -u github.com/stretchr/testify@latest
            go get -u github.com/caarlos0/env@latest
            go get -u gopkg.in/yaml.v3@latest
            go mod tidy
            go mod verify
            cd - > /dev/null
          fi
        done

    - name: ğŸ”§ Auto-Remediate Python Dependencies
      run: |
        echo "ğŸ Remediating Python dependencies..."
        
        # Update requirements.txt
        if [ -f "requirements.txt" ]; then
          echo "Updating requirements.txt..."
          cat > requirements.txt << 'EOF'
        # Core Python dependencies for CI/CD pipeline
        # This file is used by GitHub Actions to install Python dependencies

        # Development and testing tools
        black==24.3.0
        flake8==7.0.0
        mypy==1.8.0
        pytest==8.0.0

        # Security scanning tools
        bandit==1.7.5
        safety==3.0.1

        # Infrastructure tools - Updated to fix CVEs
        ansible==9.0.0
        ansible-core==2.17.6  # Fixes CVE-2024-8775
        ansible-lint==24.0.0

        # Additional utilities
        pre-commit==3.6.0

        # Security updates
        cryptography>=42.0.4  # Fixes CVE-2023-50782 and CVE-2024-26130
        requests>=2.31.0
        pyyaml>=6.0.1
        jinja2>=3.1.2
        EOF
        fi
        
        # Update Pipfile and regenerate Pipfile.lock
        find . -name "Pipfile" -type f | while read pipfile; do
          echo "Updating $pipfile..."
          pipfile_dir=$(dirname "$pipfile")
          cd "$pipfile_dir"
          
          # Update Pipfile with secure versions
          cat > Pipfile << 'EOF'
        [[source]]
        url = "https://pypi.org/simple"
        verify_ssl = true
        name = "pypi"

        [packages]
        # AWS SDK for Python
        boto3 = ">=1.34.0"
        botocore = ">=1.34.0"

        # Ansible - Updated to fix CVE-2024-8775
        ansible = ">=9.0.0"
        ansible-core = ">=2.17.6"

        # Additional useful packages for infrastructure automation
        requests = ">=2.31.0"
        pyyaml = ">=6.0.1"
        jinja2 = ">=3.1.2"
        cryptography = ">=42.0.4"  # Fixes CVE-2023-50782 and CVE-2024-26130

        [dev-packages]
        # Development and testing dependencies
        pytest = ">=8.0.0"
        pytest-cov = ">=4.0.0"
        black = ">=24.0.0"
        flake8 = ">=7.0.0"
        mypy = ">=1.8.0"
        pre-commit = ">=3.6.0"

        # Documentation
        sphinx = ">=7.0.0"
        sphinx-rtd-theme = ">=2.0.0"

        [requires]
        python_version = "3.11"

        [scripts]
        # Convenience scripts
        test = "pytest"
        format = "black ."
        lint = "flake8 ."
        type-check = "mypy ."
        inventory-list = "python ec2.py --list --pretty"
        inventory-host = "python ec2.py --host"
        ansible-ping = "ansible webservers -m ping"
        ansible-playbook = "ansible-playbook"
        EOF
          
          # Regenerate Pipfile.lock
          pipenv lock
          cd - > /dev/null
        done

    - name: ğŸ”§ Auto-Remediate Docker Images
      run: |
        echo "ğŸ³ Remediating Docker images..."
        
        find . -name "Dockerfile*" -type f | while read dockerfile; do
          echo "Updating $dockerfile..."
          
          # Update base images to latest secure versions
          sed -i 's/FROM golang:[0-9.]*-alpine[0-9.]*/FROM golang:1.21.5-alpine3.19/g' "$dockerfile"
          sed -i 's/FROM alpine:[0-9.]*/FROM alpine:3.19/g' "$dockerfile"
          sed -i 's/FROM ubuntu:[0-9.]*/FROM ubuntu:22.04/g' "$dockerfile"
          sed -i 's/FROM node:[0-9.]*-alpine[0-9.]*/FROM node:20-alpine3.19/g' "$dockerfile"
          
          # Add security updates
          if grep -q "apk add" "$dockerfile"; then
            sed -i 's/apk add/apk add --no-cache/g' "$dockerfile"
            sed -i '/apk add/a\    apk upgrade --no-cache' "$dockerfile"
          fi
          
          # Add security headers
          if grep -q "EXPOSE" "$dockerfile"; then
            sed -i '/EXPOSE/a\# Security: Run as non-root user\nRUN addgroup -g 1001 -S appgroup && adduser -u 1001 -S appuser -G appgroup\nUSER appuser' "$dockerfile"
          fi
        done

    - name: ğŸ”§ Auto-Remediate Node.js Dependencies
      run: |
        echo "ğŸ“¦ Remediating Node.js dependencies..."
        
        find . -name "package.json" -type f | while read packagejson; do
          echo "Updating $packagejson..."
          packagejson_dir=$(dirname "$packagejson")
          cd "$packagejson_dir"
          
          # Update to latest secure versions
          npm update
          npm audit fix --force
          
          cd - > /dev/null
        done

    - name: ğŸ” Verify Remediation
      run: |
        echo "ğŸ” Verifying CVE remediation..."
        
        # Run Trivy scan to verify fixes
        trivy fs --format table --severity HIGH,CRITICAL . > remediation-report.txt
        
        # Count remaining CVEs
        CRITICAL_COUNT=$(trivy fs --format json --severity CRITICAL . | jq '[.Results[]?.Vulnerabilities[]? | select(.Severity == "CRITICAL")] | length')
        HIGH_COUNT=$(trivy fs --format json --severity HIGH . | jq '[.Results[]?.Vulnerabilities[]? | select(.Severity == "HIGH")] | length')
        TOTAL_REMAINING=$((CRITICAL_COUNT + HIGH_COUNT))
        
        echo "ğŸ“Š Post-Remediation CVE Count:"
        echo "  Critical: $CRITICAL_COUNT"
        echo "  High: $HIGH_COUNT"
        echo "  Total Remaining: $TOTAL_REMAINING"
        
        # Fail if critical CVEs remain
        if [ "$CRITICAL_COUNT" -gt 0 ]; then
          echo "âŒ Critical CVEs still remain after remediation"
          exit 1
        fi
        
        echo "âœ… CVE remediation completed successfully"

    - name: ğŸ“‹ Upload Remediation Report
      uses: actions/upload-artifact@v4
      if: always()
      with:
        name: remediation-report
        path: remediation-report.txt
        retention-days: 30

    - name: ğŸ“ Create Remediation Commit
      if: github.event_name != 'pull_request'
      run: |
        echo "ğŸ“ Creating remediation commit..."
        
        # Configure Git
        git config --global user.name "CVE Auto-Remediation Bot"
        git config --global user.email "cve-bot@noreply.github.com"
        
        # Check if there are changes
        if ! git diff --quiet; then
          echo "ğŸ“Š CVE Remediation Summary:"
          echo "  Original CVE Count: ${{ needs.detect-cves.outputs.cve-count }}"
          echo "  CVEs Fixed: ${{ needs.detect-cves.outputs.cve-details }}"
          
          # Create commit message
          COMMIT_MSG="ğŸ”’ Auto-remediate CVEs - ${{ needs.detect-cves.outputs.cve-details }}"
          
          # Add all changes
          git add -A
          
          # Create commit
          git commit -m "$COMMIT_MSG"
          
          echo "âœ… Remediation commit created"
        else
          echo "â„¹ï¸ No changes needed for CVE remediation"
        fi

    - name: ğŸ·ï¸ Create Security Tag
      if: github.event_name != 'pull_request'
      run: |
        echo "ğŸ·ï¸ Creating security tag..."
        
        # Generate tag name with timestamp
        TIMESTAMP=$(date +"%Y%m%d-%H%M%S")
        TAG_NAME="security-fix-${TIMESTAMP}"
        
        # Create and push tag
        git tag -a "$TAG_NAME" -m "ğŸ”’ Security fix: CVE remediation $TIMESTAMP"
        git push origin "$TAG_NAME"
        
        echo "âœ… Security tag created: $TAG_NAME"

    - name: ğŸ“¤ Push Changes
      if: github.event_name != 'pull_request'
      run: |
        echo "ğŸ“¤ Pushing CVE remediation changes..."
        
        # Push to current branch
        git push origin HEAD
        
        echo "âœ… CVE remediation changes pushed"

    - name: ğŸ“¢ Create Security Alert Issue
      if: github.event_name != 'pull_request' && needs.detect-cves.outputs.cves-found == 'true'
      uses: actions/github-script@v7
      with:
        script: |
          const cveCount = '${{ needs.detect-cves.outputs.cve-count }}';
          const cveDetails = `${{ needs.detect-cves.outputs.cve-details }}`;
          
          const issue = await github.rest.issues.create({
            owner: context.repo.owner,
            repo: context.repo.repo,
            title: `ğŸ”’ Security Alert: ${cveCount} CVEs Detected and Remediated`,
            body: `## ğŸš¨ Security Alert: CVE Detection and Remediation
            
            **Date:** ${new Date().toISOString()}
            **CVEs Found:** ${cveCount}
            **Status:** âœ… Automatically Remediated
            
            ### CVEs Fixed:
            \`\`\`
            ${cveDetails}
            \`\`\`
            
            ### Actions Taken:
            - ğŸ” Automated CVE detection using Trivy
            - ğŸ”§ Automatic dependency updates
            - ğŸ³ Docker image security updates
            - ğŸ“ Automatic commit and tagging
            - ğŸ·ï¸ Security tag created: \`security-fix-${new Date().toISOString().slice(0,10)}\`
            
            ### Verification:
            - âœ… Post-remediation scan completed
            - âœ… No critical CVEs remaining
            - ğŸ›¡ï¸ Security posture improved
            
            ---
            *This issue was automatically created by the CVE Auto-Remediation pipeline.*`,
            labels: ['security', 'automated', 'cve-remediation']
          });
          
          console.log(`Created security alert issue: ${issue.data.html_url}`);

  notify-completion:
    name: ğŸ“¢ Notify Completion
    runs-on: ubuntu-latest
    needs: [detect-cves, remediate-cves]
    if: always()
    
    steps:
    - name: ğŸ“¢ Notify Security Team
      if: needs.detect-cves.outputs.cves-found == 'true'
      run: |
        echo "ğŸ“¢ CVE remediation completed!"
        echo "ğŸ“Š Summary:"
        echo "  CVEs Found: ${{ needs.detect-cves.outputs.cve-count }}"
        echo "  Remediation Status: ${{ needs.remediate-cves.result }}"
        echo "  Repository: ${{ github.repository }}"
        echo "  Branch: ${{ github.ref_name }}"
        echo "  Commit: ${{ github.sha }}"
        
        # Here you could add Slack/Teams/Discord notifications
        # curl -X POST -H 'Content-type: application/json' \
        #   --data '{"text":"ğŸ”’ CVE remediation completed for ${{ github.repository }}"}' \
        #   ${{ secrets.SLACK_WEBHOOK_URL }}
