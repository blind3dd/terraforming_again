# Complete Environment Flow Architecture

## ğŸ¯ Goal: Unified Environment Propagation

```
Source Code â†’ Terraform â†’ Ansible â†’ GitHub Actions â†’ ArgoCD â†’ Kubernetes
     â†“            â†“          â†“            â†“             â†“           â†“
   main/     infra as    config as   CI/CD with   GitOps      Apps
 working    code (IaC)   code (CaC)   OIDC auth   deploy    running
```

---

## ğŸ—ï¸ Layer 1: Terraform (Infrastructure)

**Location:** `infrastructure/terraform/environments/{env}/`

**What it does:**
- Creates VPC, subnets, EC2, RDS
- Outputs infrastructure details
- Tags all resources with `env={environment}`

**Outputs to pass forward:**

```hcl
# infrastructure/terraform/environments/dev/outputs.tf
output "vpc_id" {
  value = module.networking.vpc_id
}

output "private_subnet_ids" {
  value = module.networking.private_subnet_ids
}

output "rds_endpoint" {
  value = module.database.rds_endpoint
}

output "rds_database_name" {
  value = module.database.database_name
}

output "k8s_cluster_endpoint" {
  value = module.compute.cluster_endpoint  # If using EKS
}

# CRITICAL: Output to file for next stage
resource "local_file" "ansible_inventory" {
  filename = "${path.root}/../../../../ansible/inventory/${var.environment}/hosts.yml"
  content  = templatefile("${path.module}/templates/ansible-hosts.tpl", {
    environment       = var.environment
    ec2_instances     = module.compute.instance_ips
    rds_endpoint      = module.database.rds_endpoint
    vpc_id           = module.networking.vpc_id
    private_subnets  = module.networking.private_subnet_ids
  })
}
```

**Template:** `infrastructure/terraform/environments/dev/templates/ansible-hosts.tpl`
```yaml
# Auto-generated by Terraform
all:
  vars:
    environment: ${environment}
    vpc_id: ${vpc_id}
    rds_endpoint: ${rds_endpoint}
  
  children:
    ${environment}:
      hosts:
%{ for ip in ec2_instances ~}
        ${ip}:
          ansible_host: ${ip}
%{ endfor ~}
```

---

## ğŸ—ï¸ Layer 2: Ansible (Configuration)

**Location:** `infrastructure/ansible/`

**What it does:**
- Reads inventory from Terraform output
- Configures EC2 instances
- Deploys Kubernetes manifests
- Sets up Helm/Kustomize

**Inventory Structure:**

```
infrastructure/ansible/
â”œâ”€â”€ inventory/
â”‚   â”œâ”€â”€ dev/
â”‚   â”‚   â””â”€â”€ hosts.yml        â† Generated by Terraform
â”‚   â”œâ”€â”€ test/
â”‚   â”‚   â””â”€â”€ hosts.yml
â”‚   â””â”€â”€ prod/
â”‚       â””â”€â”€ hosts.yml
â”œâ”€â”€ group_vars/
â”‚   â”œâ”€â”€ all.yml              â† Common vars
â”‚   â”œâ”€â”€ dev.yml              â† Dev-specific vars
â”‚   â”œâ”€â”€ test.yml             â† Test-specific vars
â”‚   â””â”€â”€ prod.yml             â† Prod-specific vars
â””â”€â”€ playbooks/
    â””â”€â”€ deploy-k8s-apps.yml
```

**Group Vars:** `infrastructure/ansible/group_vars/dev.yml`
```yaml
---
# Dev environment variables
environment: dev
k8s_namespace: dev

# ArgoCD configuration (to be deployed)
argocd_apps:
  - name: go-mysql-api
    repo: https://github.com/blind3dd/terraforming_again
    path: infrastructure/kubernetes/overlays/dev
    namespace: dev
    auto_sync: true

# Helm releases
helm_releases:
  - name: karpenter
    chart: oci://public.ecr.aws/karpenter/karpenter
    namespace: karpenter
    values_file: "{{ playbook_dir }}/../helm-kustomize/karpenter/values.yaml"

# Kustomize overlays
kustomize_overlays:
  - path: "{{ playbook_dir }}/../helm-kustomize/go-mysql-api/kustomize/overlays/dev"
    namespace: dev
```

**Playbook:** `infrastructure/ansible/playbooks/deploy-k8s-apps.yml`
```yaml
---
- name: Deploy Kubernetes Applications
  hosts: "{{ environment | default('dev') }}"
  vars:
    environment: "{{ environment }}"
  
  tasks:
    - name: Deploy ArgoCD Applications
      kubernetes.core.k8s:
        state: present
        definition: "{{ lookup('template', 'argocd-app.yml.j2') }}"
      loop: "{{ argocd_apps }}"
      loop_control:
        loop_var: app
```

---

## ğŸ—ï¸ Layer 3: GitHub Actions (CI/CD)

**Location:** `.github/workflows/ci-cd-pipeline.yml`

**Environment-aware deployment:**

```yaml
name: Environment Deploy Pipeline

on:
  push:
    branches: [main, working_branch]
    paths:
      - 'infrastructure/terraform/environments/**'
      - 'infrastructure/ansible/**'

jobs:
  # Detect which environment changed
  detect-environment:
    runs-on: ubuntu-latest
    outputs:
      changed_env: ${{ steps.detect.outputs.environment }}
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 2
      
      - id: detect
        run: |
          # Check which environment directory changed
          CHANGED_FILES=$(git diff --name-only HEAD^ HEAD)
          if echo "$CHANGED_FILES" | grep -q "environments/dev/"; then
            echo "environment=dev" >> $GITHUB_OUTPUT
          elif echo "$CHANGED_FILES" | grep -q "environments/test/"; then
            echo "environment=test" >> $GITHUB_OUTPUT
          elif echo "$CHANGED_FILES" | grep -q "environments/prod/"; then
            echo "environment=prod" >> $GITHUB_OUTPUT
          fi

  # Deploy infrastructure
  terraform-deploy:
    needs: [detect-environment]
    if: needs.detect-environment.outputs.changed_env != ''
    runs-on: ubuntu-latest
    environment: ${{ needs.detect-environment.outputs.changed_env }}  # Dynamic!
    
    steps:
      - uses: actions/checkout@v4
      
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_TO_ASSUME }}  # Per-env secret
          role-session-name: github-${{ github.run_id }}
          aws-region: us-east-1
      
      - name: Terraform Apply
        working-directory: infrastructure/terraform/environments/${{ needs.detect-environment.outputs.changed_env }}
        run: |
          terraform init
          terraform workspace select ${{ needs.detect-environment.outputs.changed_env }} || \
            terraform workspace new ${{ needs.detect-environment.outputs.changed_env }}
          terraform apply -auto-approve
      
      - name: Save Terraform Outputs
        working-directory: infrastructure/terraform/environments/${{ needs.detect-environment.outputs.changed_env }}
        run: |
          # Export outputs for Ansible
          terraform output -json > /tmp/tf-outputs.json
      
      - name: Upload Terraform Outputs
        uses: actions/upload-artifact@v4
        with:
          name: terraform-outputs-${{ needs.detect-environment.outputs.changed_env }}
          path: /tmp/tf-outputs.json

  # Configure with Ansible
  ansible-configure:
    needs: [detect-environment, terraform-deploy]
    runs-on: ubuntu-latest
    environment: ${{ needs.detect-environment.outputs.changed_env }}
    
    steps:
      - uses: actions/checkout@v4
      
      - name: Download Terraform Outputs
        uses: actions/download-artifact@v4
        with:
          name: terraform-outputs-${{ needs.detect-environment.outputs.changed_env }}
          path: /tmp
      
      - name: Run Ansible Playbook
        run: |
          ENV=${{ needs.detect-environment.outputs.changed_env }}
          
          # Run ansible with environment-specific inventory
          ansible-playbook \
            -i infrastructure/ansible/inventory/${ENV}/hosts.yml \
            -e "environment=${ENV}" \
            -e "@/tmp/tf-outputs.json" \
            infrastructure/ansible/playbooks/deploy-k8s-apps.yml

  # Sync ArgoCD
  argocd-sync:
    needs: [detect-environment, ansible-configure]
    runs-on: ubuntu-latest
    environment: ${{ needs.detect-environment.outputs.changed_env }}
    
    steps:
      - name: Trigger ArgoCD Sync
        run: |
          ENV=${{ needs.detect-environment.outputs.changed_env }}
          
          # ArgoCD will detect changes and sync
          # Or manually trigger:
          argocd app sync go-mysql-api-${ENV} \
            --server ${{ secrets.ARGOCD_SERVER }} \
            --auth-token ${{ secrets.ARGOCD_TOKEN }}
```

---

## ğŸ—ï¸ Layer 4: ArgoCD (GitOps)

**Location:** `platform/argocd/applications/`

**Environment-specific apps:**

```yaml
# platform/argocd/applications/dev/go-mysql-api.yaml
apiVersion: argoproj.io/v1alpha1
kind: Application
metadata:
  name: go-mysql-api-dev
  namespace: argocd
spec:
  project: default
  
  source:
    repoURL: https://github.com/blind3dd/terraforming_again
    targetRevision: main
    path: infrastructure/kubernetes/overlays/dev  # Environment-specific path
  
  destination:
    server: https://kubernetes.default.svc
    namespace: dev
  
  syncPolicy:
    automated:
      prune: true
      selfHeal: true
    syncOptions:
      - CreateNamespace=true
  
  # Inject Terraform outputs as parameters
  helm:
    parameters:
      - name: database.host
        value: $ARGOCD_ENV_RDS_ENDPOINT  # From Terraform
      - name: database.name
        value: $ARGOCD_ENV_DB_NAME
```

---

## ğŸ—ï¸ Layer 5: Helm & Kustomize (Application)

**Location:** `infrastructure/kubernetes/overlays/{env}/`

### **Kustomize Structure:**

```
infrastructure/kubernetes/
â”œâ”€â”€ base/                    # Common resources
â”‚   â”œâ”€â”€ deployment.yaml
â”‚   â”œâ”€â”€ service.yaml
â”‚   â””â”€â”€ kustomization.yaml
â””â”€â”€ overlays/
    â”œâ”€â”€ dev/
    â”‚   â”œâ”€â”€ kustomization.yaml
    â”‚   â”œâ”€â”€ patches/
    â”‚   â”‚   â”œâ”€â”€ replicas.yaml      # 1 replica for dev
    â”‚   â”‚   â””â”€â”€ resources.yaml     # Small resources
    â”‚   â””â”€â”€ values-dev.yaml        # Dev-specific values
    â”œâ”€â”€ test/
    â”‚   â”œâ”€â”€ kustomization.yaml
    â”‚   â””â”€â”€ patches/
    â”‚       â”œâ”€â”€ replicas.yaml      # 2 replicas for test
    â”‚       â””â”€â”€ resources.yaml     # Medium resources
    â””â”€â”€ prod/
        â”œâ”€â”€ kustomization.yaml
        â””â”€â”€ patches/
            â”œâ”€â”€ replicas.yaml      # 3+ replicas for prod
            â”œâ”€â”€ resources.yaml     # Large resources
            â””â”€â”€ hpa.yaml           # Auto-scaling
```

**Dev Kustomization:** `infrastructure/kubernetes/overlays/dev/kustomization.yaml`
```yaml
apiVersion: kustomize.config.k8s.io/v1beta1
kind: Kustomization

namespace: dev

resources:
  - ../../base

commonLabels:
  environment: dev
  managed-by: argocd

patches:
  - path: patches/replicas.yaml
  - path: patches/resources.yaml

configMapGenerator:
  - name: app-config
    literals:
      - ENVIRONMENT=dev
      - LOG_LEVEL=debug
      - DB_HOST=${RDS_ENDPOINT}  # From Terraform via ArgoCD

helmCharts:
  - name: go-mysql-api
    repo: oci://ghcr.io/blind3dd/charts
    version: 0.1.0
    releaseName: go-mysql-api
    namespace: dev
    valuesFile: values-dev.yaml
```

---

## ğŸ“Š Complete Data Flow

### **1. Terraform Creates Infrastructure**
```bash
cd infrastructure/terraform/environments/dev
terraform apply

# Outputs:
# - vpc_id
# - rds_endpoint
# - ec2_ips
# â†“
# Writes to: infrastructure/ansible/inventory/dev/hosts.yml
```

### **2. Ansible Configures & Deploys**
```bash
ansible-playbook \
  -i infrastructure/ansible/inventory/dev/hosts.yml \
  -e "environment=dev" \
  infrastructure/ansible/playbooks/deploy-k8s-apps.yml

# Does:
# - Installs K8s on EC2
# - Deploys ArgoCD
# - Creates ArgoCD Applications
# - Configures Helm repos
# â†“
# Deploys: platform/argocd/applications/dev/*.yaml
```

### **3. GitHub Actions Orchestrates**
```yaml
# Triggered by: git push
# Uses: GitHub Environment 'dev' for secrets
# Runs:
#   1. terraform apply (Layer 1)
#   2. ansible-playbook (Layer 2)
#   3. argocd app sync (Layer 3)
# â†“
# ArgoCD detects changes
```

### **4. ArgoCD Syncs Applications**
```yaml
# Watches: infrastructure/kubernetes/overlays/dev/
# Detects: Kustomization changes
# Syncs: Applications to K8s cluster
# â†“
# Helm/Kustomize renders manifests
```

### **5. Helm/Kustomize Renders**
```yaml
# Processes:
#   - Base manifests
#   - Environment patches
#   - ConfigMaps with Terraform outputs
# â†“
# Deploys to: K8s namespace 'dev'
```

---

## ğŸ”§ Implementation: Environment Variable Passing

### **Step 1: Terraform â†’ Ansible**

```hcl
# infrastructure/terraform/environments/dev/outputs.tf
output "ansible_inventory" {
  value = {
    environment    = var.environment
    vpc_id        = module.networking.vpc_id
    rds_endpoint  = module.database.rds_endpoint
    rds_database  = module.database.database_name
    rds_username  = var.db_username
    ec2_instances = module.compute.instance_ips
  }
}

# Write to Ansible inventory
resource "local_file" "ansible_vars" {
  filename = "${path.root}/../../../../ansible/group_vars/${var.environment}.yml"
  content  = yamlencode({
    # From Terraform
    terraform_vpc_id       = module.networking.vpc_id
    terraform_rds_endpoint = module.database.rds_endpoint
    terraform_rds_database = module.database.database_name
    
    # For Kubernetes
    k8s_namespace = var.environment
    environment   = var.environment
  })
}
```

### **Step 2: Ansible â†’ Kubernetes ConfigMaps**

```yaml
# infrastructure/ansible/playbooks/deploy-k8s-apps.yml
- name: Create Kubernetes ConfigMap with Terraform outputs
  kubernetes.core.k8s:
    state: present
    definition:
      apiVersion: v1
      kind: ConfigMap
      metadata:
        name: terraform-outputs
        namespace: "{{ environment }}"
      data:
        VPC_ID: "{{ terraform_vpc_id }}"
        RDS_ENDPOINT: "{{ terraform_rds_endpoint }}"
        RDS_DATABASE: "{{ terraform_rds_database }}"
        ENVIRONMENT: "{{ environment }}"

- name: Create ArgoCD Application
  kubernetes.core.k8s:
    state: present
    definition:
      apiVersion: argoproj.io/v1alpha1
      kind: Application
      metadata:
        name: "go-mysql-api-{{ environment }}"
        namespace: argocd
      spec:
        project: default
        source:
          repoURL: https://github.com/blind3dd/terraforming_again
          targetRevision: main
          path: "infrastructure/kubernetes/overlays/{{ environment }}"
        destination:
          server: https://kubernetes.default.svc
          namespace: "{{ environment }}"
        syncPolicy:
          automated:
            prune: true
            selfHeal: true
```

### **Step 3: GitHub Actions â†’ Environment Context**

```yaml
# .github/workflows/deploy-environment.yml
jobs:
  deploy:
    strategy:
      matrix:
        environment: [dev, test]  # NOT prod (manual only)
    
    runs-on: ubuntu-latest
    environment: ${{ matrix.environment }}  # GitHub Environment
    
    steps:
      - name: Set Environment Variables
        run: |
          echo "ENV_NAME=${{ matrix.environment }}" >> $GITHUB_ENV
          echo "TF_DIR=infrastructure/terraform/environments/${{ matrix.environment }}" >> $GITHUB_ENV
          echo "ANSIBLE_INVENTORY=infrastructure/ansible/inventory/${{ matrix.environment }}" >> $GITHUB_ENV
      
      - name: Deploy Terraform
        working-directory: ${{ env.TF_DIR }}
        run: terraform apply -auto-approve
      
      - name: Configure with Ansible
        run: |
          ansible-playbook \
            -i ${{ env.ANSIBLE_INVENTORY }}/hosts.yml \
            -e "environment=${{ env.ENV_NAME }}" \
            infrastructure/ansible/playbooks/deploy-k8s-apps.yml
```

### **Step 4: ArgoCD â†’ Helm/Kustomize**

```yaml
# ArgoCD Application reads from specific overlay
apiVersion: argoproj.io/v1alpha1
kind: Application
metadata:
  name: go-mysql-api-dev
spec:
  source:
    path: infrastructure/kubernetes/overlays/dev  # Environment path
    
    # Use Helm
    helm:
      valueFiles:
        - values-dev.yaml
      parameters:
        - name: database.host
          value: $ARGOCD_ENV_RDS_ENDPOINT  # From ConfigMap
    
    # OR use Kustomize
    kustomize:
      commonLabels:
        environment: dev
```

### **Step 5: Kustomize â†’ Final Manifests**

```yaml
# infrastructure/kubernetes/overlays/dev/kustomization.yaml
apiVersion: kustomize.config.k8s.io/v1beta1
kind: Kustomization

namespace: dev

resources:
  - ../../base

configMapGenerator:
  - name: app-env-config
    literals:
      - ENVIRONMENT=dev
      - DB_HOST=$(RDS_ENDPOINT)  # Replaced at build time

replacements:
  - source:
      kind: ConfigMap
      name: terraform-outputs
      fieldPath: data.RDS_ENDPOINT
    targets:
      - select:
          kind: Deployment
        fieldPaths:
          - spec.template.spec.containers.[name=api].env.[name=DB_HOST].value
```

---

## ğŸ¯ Complete Example: Dev Environment Flow

### **1. Developer commits to `working_branch`:**
```bash
git commit -m "Update dev environment"
git push origin working_branch
```

### **2. GitHub Actions triggers:**
```yaml
on:
  push:
    branches: [working_branch]
    paths: ['infrastructure/terraform/environments/dev/**']
```

### **3. Workflow runs:**
```
1. Uses GitHub Environment 'dev'
   â”œâ”€â”€ Loads secret: AWS_ROLE_TO_ASSUME
   â””â”€â”€ Assumes role: arn:aws:iam::690248313240:role/iacrole

2. Terraform applies (dev environment)
   â”œâ”€â”€ Creates/updates infrastructure
   â”œâ”€â”€ Outputs: vpc_id, rds_endpoint, etc.
   â””â”€â”€ Writes: infrastructure/ansible/inventory/dev/hosts.yml

3. Ansible configures (dev inventory)
   â”œâ”€â”€ Reads: inventory/dev/hosts.yml
   â”œâ”€â”€ Uses: group_vars/dev.yml
   â”œâ”€â”€ Deploys: ArgoCD Application for 'dev'
   â””â”€â”€ Creates: ConfigMap with Terraform outputs

4. ArgoCD syncs (automatically)
   â”œâ”€â”€ Watches: infrastructure/kubernetes/overlays/dev/
   â”œâ”€â”€ Detects: Changes in Kustomization
   â”œâ”€â”€ Renders: Manifests with dev values
   â””â”€â”€ Deploys: To namespace 'dev'

5. Kubernetes runs application
   â”œâ”€â”€ Uses: ConfigMap 'terraform-outputs'
   â”œâ”€â”€ Connects: To RDS endpoint from Terraform
   â””â”€â”€ Runs: In namespace 'dev'
```

---

## ğŸ“ Complete Directory Structure

```
terraforming_again/
â”œâ”€â”€ infrastructure/
â”‚   â”œâ”€â”€ terraform/
â”‚   â”‚   â””â”€â”€ environments/
â”‚   â”‚       â”œâ”€â”€ dev/
â”‚   â”‚       â”‚   â”œâ”€â”€ main.tf
â”‚   â”‚       â”‚   â”œâ”€â”€ terraform.tfvars        # ENV: dev
â”‚   â”‚       â”‚   â”œâ”€â”€ outputs.tf              # â†’ Ansible
â”‚   â”‚       â”‚   â””â”€â”€ templates/
â”‚   â”‚       â”‚       â””â”€â”€ ansible-hosts.tpl
â”‚   â”‚       â”œâ”€â”€ test/
â”‚   â”‚       â””â”€â”€ prod/
â”‚   â”œâ”€â”€ ansible/
â”‚   â”‚   â”œâ”€â”€ inventory/
â”‚   â”‚   â”‚   â”œâ”€â”€ dev/
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ hosts.yml              # â† From Terraform
â”‚   â”‚   â”‚   â”œâ”€â”€ test/
â”‚   â”‚   â”‚   â””â”€â”€ prod/
â”‚   â”‚   â”œâ”€â”€ group_vars/
â”‚   â”‚   â”‚   â”œâ”€â”€ dev.yml                    # ENV: dev â†’ ArgoCD
â”‚   â”‚   â”‚   â”œâ”€â”€ test.yml
â”‚   â”‚   â”‚   â””â”€â”€ prod.yml
â”‚   â”‚   â””â”€â”€ playbooks/
â”‚   â”‚       â””â”€â”€ deploy-k8s-apps.yml        # â†’ ArgoCD apps
â”‚   â””â”€â”€ kubernetes/
â”‚       â”œâ”€â”€ base/                          # Common manifests
â”‚       â””â”€â”€ overlays/
â”‚           â”œâ”€â”€ dev/                       # ENV: dev
â”‚           â”‚   â”œâ”€â”€ kustomization.yaml     # â† ArgoCD watches
â”‚           â”‚   â”œâ”€â”€ values-dev.yaml        # Helm values
â”‚           â”‚   â””â”€â”€ patches/
â”‚           â”œâ”€â”€ test/
â”‚           â””â”€â”€ prod/
â”œâ”€â”€ platform/
â”‚   â””â”€â”€ argocd/
â”‚       â””â”€â”€ applications/
â”‚           â”œâ”€â”€ dev/
â”‚           â”‚   â””â”€â”€ go-mysql-api.yaml      # â† Deployed by Ansible
â”‚           â”œâ”€â”€ test/
â”‚           â””â”€â”€ prod/
â””â”€â”€ .github/
    â””â”€â”€ workflows/
        â””â”€â”€ deploy-environment.yml          # Uses GitHub Env: dev/test/prod
```

---

## ğŸ” Secret Management Flow

```
GitHub Environment Secrets
    â†“
GitHub Actions (OIDC)
    â†“
AWS Secrets Manager / SSM
    â†“
Terraform (creates secrets)
    â†“
Ansible (deploys K8s secrets)
    â†“
ArgoCD (external secrets operator)
    â†“
Kubernetes Secrets
    â†“
Application Pods
```

---

## âœ… Implementation Checklist

- [ ] Create Terraform output templates for Ansible
- [ ] Structure Ansible group_vars by environment
- [ ] Create Kustomize overlays for each environment
- [ ] Set up ArgoCD Application CRDs
- [ ] Update GitHub Actions to pass environment context
- [ ] Configure GitHub Environments (dev, test, prod)
- [ ] Test the complete flow end-to-end

---

**This gives you a complete, production-ready GitOps pipeline!** ğŸš€

Want me to start implementing this?

