# Complete Environment Flow Architecture

## 🎯 Goal: Unified Environment Propagation

```
Source Code → Terraform → Ansible → GitHub Actions → ArgoCD → Kubernetes
     ↓            ↓          ↓            ↓             ↓           ↓
   main/     infra as    config as   CI/CD with   GitOps      Apps
 working    code (IaC)   code (CaC)   OIDC auth   deploy    running
```

---

## 🏗️ Layer 1: Terraform (Infrastructure)

**Location:** `infrastructure/terraform/environments/{env}/`

**What it does:**
- Creates VPC, subnets, EC2, RDS
- Outputs infrastructure details
- Tags all resources with `env={environment}`

**Outputs to pass forward:**

```hcl
# infrastructure/terraform/environments/dev/outputs.tf
output "vpc_id" {
  value = module.networking.vpc_id
}

output "private_subnet_ids" {
  value = module.networking.private_subnet_ids
}

output "rds_endpoint" {
  value = module.database.rds_endpoint
}

output "rds_database_name" {
  value = module.database.database_name
}

output "k8s_cluster_endpoint" {
  value = module.compute.cluster_endpoint  # If using EKS
}

# CRITICAL: Output to file for next stage
resource "local_file" "ansible_inventory" {
  filename = "${path.root}/../../../../ansible/inventory/${var.environment}/hosts.yml"
  content  = templatefile("${path.module}/templates/ansible-hosts.tpl", {
    environment       = var.environment
    ec2_instances     = module.compute.instance_ips
    rds_endpoint      = module.database.rds_endpoint
    vpc_id           = module.networking.vpc_id
    private_subnets  = module.networking.private_subnet_ids
  })
}
```

**Template:** `infrastructure/terraform/environments/dev/templates/ansible-hosts.tpl`
```yaml
# Auto-generated by Terraform
all:
  vars:
    environment: ${environment}
    vpc_id: ${vpc_id}
    rds_endpoint: ${rds_endpoint}
  
  children:
    ${environment}:
      hosts:
%{ for ip in ec2_instances ~}
        ${ip}:
          ansible_host: ${ip}
%{ endfor ~}
```

---

## 🏗️ Layer 2: Ansible (Configuration)

**Location:** `infrastructure/ansible/`

**What it does:**
- Reads inventory from Terraform output
- Configures EC2 instances
- Deploys Kubernetes manifests
- Sets up Helm/Kustomize

**Inventory Structure:**

```
infrastructure/ansible/
├── inventory/
│   ├── dev/
│   │   └── hosts.yml        ← Generated by Terraform
│   ├── test/
│   │   └── hosts.yml
│   └── prod/
│       └── hosts.yml
├── group_vars/
│   ├── all.yml              ← Common vars
│   ├── dev.yml              ← Dev-specific vars
│   ├── test.yml             ← Test-specific vars
│   └── prod.yml             ← Prod-specific vars
└── playbooks/
    └── deploy-k8s-apps.yml
```

**Group Vars:** `infrastructure/ansible/group_vars/dev.yml`
```yaml
---
# Dev environment variables
environment: dev
k8s_namespace: dev

# ArgoCD configuration (to be deployed)
argocd_apps:
  - name: go-mysql-api
    repo: https://github.com/blind3dd/terraforming_again
    path: infrastructure/kubernetes/overlays/dev
    namespace: dev
    auto_sync: true

# Helm releases
helm_releases:
  - name: karpenter
    chart: oci://public.ecr.aws/karpenter/karpenter
    namespace: karpenter
    values_file: "{{ playbook_dir }}/../helm-kustomize/karpenter/values.yaml"

# Kustomize overlays
kustomize_overlays:
  - path: "{{ playbook_dir }}/../helm-kustomize/go-mysql-api/kustomize/overlays/dev"
    namespace: dev
```

**Playbook:** `infrastructure/ansible/playbooks/deploy-k8s-apps.yml`
```yaml
---
- name: Deploy Kubernetes Applications
  hosts: "{{ environment | default('dev') }}"
  vars:
    environment: "{{ environment }}"
  
  tasks:
    - name: Deploy ArgoCD Applications
      kubernetes.core.k8s:
        state: present
        definition: "{{ lookup('template', 'argocd-app.yml.j2') }}"
      loop: "{{ argocd_apps }}"
      loop_control:
        loop_var: app
```

---

## 🏗️ Layer 3: GitHub Actions (CI/CD)

**Location:** `.github/workflows/ci-cd-pipeline.yml`

**Environment-aware deployment:**

```yaml
name: Environment Deploy Pipeline

on:
  push:
    branches: [main, working_branch]
    paths:
      - 'infrastructure/terraform/environments/**'
      - 'infrastructure/ansible/**'

jobs:
  # Detect which environment changed
  detect-environment:
    runs-on: ubuntu-latest
    outputs:
      changed_env: ${{ steps.detect.outputs.environment }}
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 2
      
      - id: detect
        run: |
          # Check which environment directory changed
          CHANGED_FILES=$(git diff --name-only HEAD^ HEAD)
          if echo "$CHANGED_FILES" | grep -q "environments/dev/"; then
            echo "environment=dev" >> $GITHUB_OUTPUT
          elif echo "$CHANGED_FILES" | grep -q "environments/test/"; then
            echo "environment=test" >> $GITHUB_OUTPUT
          elif echo "$CHANGED_FILES" | grep -q "environments/prod/"; then
            echo "environment=prod" >> $GITHUB_OUTPUT
          fi

  # Deploy infrastructure
  terraform-deploy:
    needs: [detect-environment]
    if: needs.detect-environment.outputs.changed_env != ''
    runs-on: ubuntu-latest
    environment: ${{ needs.detect-environment.outputs.changed_env }}  # Dynamic!
    
    steps:
      - uses: actions/checkout@v4
      
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_TO_ASSUME }}  # Per-env secret
          role-session-name: github-${{ github.run_id }}
          aws-region: us-east-1
      
      - name: Terraform Apply
        working-directory: infrastructure/terraform/environments/${{ needs.detect-environment.outputs.changed_env }}
        run: |
          terraform init
          terraform workspace select ${{ needs.detect-environment.outputs.changed_env }} || \
            terraform workspace new ${{ needs.detect-environment.outputs.changed_env }}
          terraform apply -auto-approve
      
      - name: Save Terraform Outputs
        working-directory: infrastructure/terraform/environments/${{ needs.detect-environment.outputs.changed_env }}
        run: |
          # Export outputs for Ansible
          terraform output -json > /tmp/tf-outputs.json
      
      - name: Upload Terraform Outputs
        uses: actions/upload-artifact@v4
        with:
          name: terraform-outputs-${{ needs.detect-environment.outputs.changed_env }}
          path: /tmp/tf-outputs.json

  # Configure with Ansible
  ansible-configure:
    needs: [detect-environment, terraform-deploy]
    runs-on: ubuntu-latest
    environment: ${{ needs.detect-environment.outputs.changed_env }}
    
    steps:
      - uses: actions/checkout@v4
      
      - name: Download Terraform Outputs
        uses: actions/download-artifact@v4
        with:
          name: terraform-outputs-${{ needs.detect-environment.outputs.changed_env }}
          path: /tmp
      
      - name: Run Ansible Playbook
        run: |
          ENV=${{ needs.detect-environment.outputs.changed_env }}
          
          # Run ansible with environment-specific inventory
          ansible-playbook \
            -i infrastructure/ansible/inventory/${ENV}/hosts.yml \
            -e "environment=${ENV}" \
            -e "@/tmp/tf-outputs.json" \
            infrastructure/ansible/playbooks/deploy-k8s-apps.yml

  # Sync ArgoCD
  argocd-sync:
    needs: [detect-environment, ansible-configure]
    runs-on: ubuntu-latest
    environment: ${{ needs.detect-environment.outputs.changed_env }}
    
    steps:
      - name: Trigger ArgoCD Sync
        run: |
          ENV=${{ needs.detect-environment.outputs.changed_env }}
          
          # ArgoCD will detect changes and sync
          # Or manually trigger:
          argocd app sync go-mysql-api-${ENV} \
            --server ${{ secrets.ARGOCD_SERVER }} \
            --auth-token ${{ secrets.ARGOCD_TOKEN }}
```

---

## 🏗️ Layer 4: ArgoCD (GitOps)

**Location:** `platform/argocd/applications/`

**Environment-specific apps:**

```yaml
# platform/argocd/applications/dev/go-mysql-api.yaml
apiVersion: argoproj.io/v1alpha1
kind: Application
metadata:
  name: go-mysql-api-dev
  namespace: argocd
spec:
  project: default
  
  source:
    repoURL: https://github.com/blind3dd/terraforming_again
    targetRevision: main
    path: infrastructure/kubernetes/overlays/dev  # Environment-specific path
  
  destination:
    server: https://kubernetes.default.svc
    namespace: dev
  
  syncPolicy:
    automated:
      prune: true
      selfHeal: true
    syncOptions:
      - CreateNamespace=true
  
  # Inject Terraform outputs as parameters
  helm:
    parameters:
      - name: database.host
        value: $ARGOCD_ENV_RDS_ENDPOINT  # From Terraform
      - name: database.name
        value: $ARGOCD_ENV_DB_NAME
```

---

## 🏗️ Layer 5: Helm & Kustomize (Application)

**Location:** `infrastructure/kubernetes/overlays/{env}/`

### **Kustomize Structure:**

```
infrastructure/kubernetes/
├── base/                    # Common resources
│   ├── deployment.yaml
│   ├── service.yaml
│   └── kustomization.yaml
└── overlays/
    ├── dev/
    │   ├── kustomization.yaml
    │   ├── patches/
    │   │   ├── replicas.yaml      # 1 replica for dev
    │   │   └── resources.yaml     # Small resources
    │   └── values-dev.yaml        # Dev-specific values
    ├── test/
    │   ├── kustomization.yaml
    │   └── patches/
    │       ├── replicas.yaml      # 2 replicas for test
    │       └── resources.yaml     # Medium resources
    └── prod/
        ├── kustomization.yaml
        └── patches/
            ├── replicas.yaml      # 3+ replicas for prod
            ├── resources.yaml     # Large resources
            └── hpa.yaml           # Auto-scaling
```

**Dev Kustomization:** `infrastructure/kubernetes/overlays/dev/kustomization.yaml`
```yaml
apiVersion: kustomize.config.k8s.io/v1beta1
kind: Kustomization

namespace: dev

resources:
  - ../../base

commonLabels:
  environment: dev
  managed-by: argocd

patches:
  - path: patches/replicas.yaml
  - path: patches/resources.yaml

configMapGenerator:
  - name: app-config
    literals:
      - ENVIRONMENT=dev
      - LOG_LEVEL=debug
      - DB_HOST=${RDS_ENDPOINT}  # From Terraform via ArgoCD

helmCharts:
  - name: go-mysql-api
    repo: oci://ghcr.io/blind3dd/charts
    version: 0.1.0
    releaseName: go-mysql-api
    namespace: dev
    valuesFile: values-dev.yaml
```

---

## 📊 Complete Data Flow

### **1. Terraform Creates Infrastructure**
```bash
cd infrastructure/terraform/environments/dev
terraform apply

# Outputs:
# - vpc_id
# - rds_endpoint
# - ec2_ips
# ↓
# Writes to: infrastructure/ansible/inventory/dev/hosts.yml
```

### **2. Ansible Configures & Deploys**
```bash
ansible-playbook \
  -i infrastructure/ansible/inventory/dev/hosts.yml \
  -e "environment=dev" \
  infrastructure/ansible/playbooks/deploy-k8s-apps.yml

# Does:
# - Installs K8s on EC2
# - Deploys ArgoCD
# - Creates ArgoCD Applications
# - Configures Helm repos
# ↓
# Deploys: platform/argocd/applications/dev/*.yaml
```

### **3. GitHub Actions Orchestrates**
```yaml
# Triggered by: git push
# Uses: GitHub Environment 'dev' for secrets
# Runs:
#   1. terraform apply (Layer 1)
#   2. ansible-playbook (Layer 2)
#   3. argocd app sync (Layer 3)
# ↓
# ArgoCD detects changes
```

### **4. ArgoCD Syncs Applications**
```yaml
# Watches: infrastructure/kubernetes/overlays/dev/
# Detects: Kustomization changes
# Syncs: Applications to K8s cluster
# ↓
# Helm/Kustomize renders manifests
```

### **5. Helm/Kustomize Renders**
```yaml
# Processes:
#   - Base manifests
#   - Environment patches
#   - ConfigMaps with Terraform outputs
# ↓
# Deploys to: K8s namespace 'dev'
```

---

## 🔧 Implementation: Environment Variable Passing

### **Step 1: Terraform → Ansible**

```hcl
# infrastructure/terraform/environments/dev/outputs.tf
output "ansible_inventory" {
  value = {
    environment    = var.environment
    vpc_id        = module.networking.vpc_id
    rds_endpoint  = module.database.rds_endpoint
    rds_database  = module.database.database_name
    rds_username  = var.db_username
    ec2_instances = module.compute.instance_ips
  }
}

# Write to Ansible inventory
resource "local_file" "ansible_vars" {
  filename = "${path.root}/../../../../ansible/group_vars/${var.environment}.yml"
  content  = yamlencode({
    # From Terraform
    terraform_vpc_id       = module.networking.vpc_id
    terraform_rds_endpoint = module.database.rds_endpoint
    terraform_rds_database = module.database.database_name
    
    # For Kubernetes
    k8s_namespace = var.environment
    environment   = var.environment
  })
}
```

### **Step 2: Ansible → Kubernetes ConfigMaps**

```yaml
# infrastructure/ansible/playbooks/deploy-k8s-apps.yml
- name: Create Kubernetes ConfigMap with Terraform outputs
  kubernetes.core.k8s:
    state: present
    definition:
      apiVersion: v1
      kind: ConfigMap
      metadata:
        name: terraform-outputs
        namespace: "{{ environment }}"
      data:
        VPC_ID: "{{ terraform_vpc_id }}"
        RDS_ENDPOINT: "{{ terraform_rds_endpoint }}"
        RDS_DATABASE: "{{ terraform_rds_database }}"
        ENVIRONMENT: "{{ environment }}"

- name: Create ArgoCD Application
  kubernetes.core.k8s:
    state: present
    definition:
      apiVersion: argoproj.io/v1alpha1
      kind: Application
      metadata:
        name: "go-mysql-api-{{ environment }}"
        namespace: argocd
      spec:
        project: default
        source:
          repoURL: https://github.com/blind3dd/terraforming_again
          targetRevision: main
          path: "infrastructure/kubernetes/overlays/{{ environment }}"
        destination:
          server: https://kubernetes.default.svc
          namespace: "{{ environment }}"
        syncPolicy:
          automated:
            prune: true
            selfHeal: true
```

### **Step 3: GitHub Actions → Environment Context**

```yaml
# .github/workflows/deploy-environment.yml
jobs:
  deploy:
    strategy:
      matrix:
        environment: [dev, test]  # NOT prod (manual only)
    
    runs-on: ubuntu-latest
    environment: ${{ matrix.environment }}  # GitHub Environment
    
    steps:
      - name: Set Environment Variables
        run: |
          echo "ENV_NAME=${{ matrix.environment }}" >> $GITHUB_ENV
          echo "TF_DIR=infrastructure/terraform/environments/${{ matrix.environment }}" >> $GITHUB_ENV
          echo "ANSIBLE_INVENTORY=infrastructure/ansible/inventory/${{ matrix.environment }}" >> $GITHUB_ENV
      
      - name: Deploy Terraform
        working-directory: ${{ env.TF_DIR }}
        run: terraform apply -auto-approve
      
      - name: Configure with Ansible
        run: |
          ansible-playbook \
            -i ${{ env.ANSIBLE_INVENTORY }}/hosts.yml \
            -e "environment=${{ env.ENV_NAME }}" \
            infrastructure/ansible/playbooks/deploy-k8s-apps.yml
```

### **Step 4: ArgoCD → Helm/Kustomize**

```yaml
# ArgoCD Application reads from specific overlay
apiVersion: argoproj.io/v1alpha1
kind: Application
metadata:
  name: go-mysql-api-dev
spec:
  source:
    path: infrastructure/kubernetes/overlays/dev  # Environment path
    
    # Use Helm
    helm:
      valueFiles:
        - values-dev.yaml
      parameters:
        - name: database.host
          value: $ARGOCD_ENV_RDS_ENDPOINT  # From ConfigMap
    
    # OR use Kustomize
    kustomize:
      commonLabels:
        environment: dev
```

### **Step 5: Kustomize → Final Manifests**

```yaml
# infrastructure/kubernetes/overlays/dev/kustomization.yaml
apiVersion: kustomize.config.k8s.io/v1beta1
kind: Kustomization

namespace: dev

resources:
  - ../../base

configMapGenerator:
  - name: app-env-config
    literals:
      - ENVIRONMENT=dev
      - DB_HOST=$(RDS_ENDPOINT)  # Replaced at build time

replacements:
  - source:
      kind: ConfigMap
      name: terraform-outputs
      fieldPath: data.RDS_ENDPOINT
    targets:
      - select:
          kind: Deployment
        fieldPaths:
          - spec.template.spec.containers.[name=api].env.[name=DB_HOST].value
```

---

## 🎯 Complete Example: Dev Environment Flow

### **1. Developer commits to `working_branch`:**
```bash
git commit -m "Update dev environment"
git push origin working_branch
```

### **2. GitHub Actions triggers:**
```yaml
on:
  push:
    branches: [working_branch]
    paths: ['infrastructure/terraform/environments/dev/**']
```

### **3. Workflow runs:**
```
1. Uses GitHub Environment 'dev'
   ├── Loads secret: AWS_ROLE_TO_ASSUME
   └── Assumes role: arn:aws:iam::690248313240:role/iacrole

2. Terraform applies (dev environment)
   ├── Creates/updates infrastructure
   ├── Outputs: vpc_id, rds_endpoint, etc.
   └── Writes: infrastructure/ansible/inventory/dev/hosts.yml

3. Ansible configures (dev inventory)
   ├── Reads: inventory/dev/hosts.yml
   ├── Uses: group_vars/dev.yml
   ├── Deploys: ArgoCD Application for 'dev'
   └── Creates: ConfigMap with Terraform outputs

4. ArgoCD syncs (automatically)
   ├── Watches: infrastructure/kubernetes/overlays/dev/
   ├── Detects: Changes in Kustomization
   ├── Renders: Manifests with dev values
   └── Deploys: To namespace 'dev'

5. Kubernetes runs application
   ├── Uses: ConfigMap 'terraform-outputs'
   ├── Connects: To RDS endpoint from Terraform
   └── Runs: In namespace 'dev'
```

---

## 📁 Complete Directory Structure

```
terraforming_again/
├── infrastructure/
│   ├── terraform/
│   │   └── environments/
│   │       ├── dev/
│   │       │   ├── main.tf
│   │       │   ├── terraform.tfvars        # ENV: dev
│   │       │   ├── outputs.tf              # → Ansible
│   │       │   └── templates/
│   │       │       └── ansible-hosts.tpl
│   │       ├── test/
│   │       └── prod/
│   ├── ansible/
│   │   ├── inventory/
│   │   │   ├── dev/
│   │   │   │   └── hosts.yml              # ← From Terraform
│   │   │   ├── test/
│   │   │   └── prod/
│   │   ├── group_vars/
│   │   │   ├── dev.yml                    # ENV: dev → ArgoCD
│   │   │   ├── test.yml
│   │   │   └── prod.yml
│   │   └── playbooks/
│   │       └── deploy-k8s-apps.yml        # → ArgoCD apps
│   └── kubernetes/
│       ├── base/                          # Common manifests
│       └── overlays/
│           ├── dev/                       # ENV: dev
│           │   ├── kustomization.yaml     # ← ArgoCD watches
│           │   ├── values-dev.yaml        # Helm values
│           │   └── patches/
│           ├── test/
│           └── prod/
├── platform/
│   └── argocd/
│       └── applications/
│           ├── dev/
│           │   └── go-mysql-api.yaml      # ← Deployed by Ansible
│           ├── test/
│           └── prod/
└── .github/
    └── workflows/
        └── deploy-environment.yml          # Uses GitHub Env: dev/test/prod
```

---

## 🔐 Secret Management Flow

```
GitHub Environment Secrets
    ↓
GitHub Actions (OIDC)
    ↓
AWS Secrets Manager / SSM
    ↓
Terraform (creates secrets)
    ↓
Ansible (deploys K8s secrets)
    ↓
ArgoCD (external secrets operator)
    ↓
Kubernetes Secrets
    ↓
Application Pods
```

---

## ✅ Implementation Checklist

- [ ] Create Terraform output templates for Ansible
- [ ] Structure Ansible group_vars by environment
- [ ] Create Kustomize overlays for each environment
- [ ] Set up ArgoCD Application CRDs
- [ ] Update GitHub Actions to pass environment context
- [ ] Configure GitHub Environments (dev, test, prod)
- [ ] Test the complete flow end-to-end

---

**This gives you a complete, production-ready GitOps pipeline!** 🚀

Want me to start implementing this?

