# Unified Environment Structure

## 🎯 Complete Environment Flow

```
Developer Commits
      ↓
GitHub Actions (CI/CD)
  ├── Uses GitHub Environment: dev/test/prod
  ├── Assumes IAM Role: iacrole
  └── Runs in order:
      ↓
1. Terraform Apply
   ├── Workspace: dev/test/prod
   ├── Creates: VPC, EC2, RDS
   ├── Tags: Environment=dev/test/prod
   └── Outputs to:
       ├── infrastructure/ansible/inventory/{env}/hosts.yml
       └── infrastructure/ansible/group_vars/{env}.yml
      ↓
2. Ansible Configure
   ├── Reads: inventory/{env}/hosts.yml
   ├── Uses: group_vars/{env}.yml
   ├── Deploys: ArgoCD Applications
   └── Creates: K8s ConfigMaps with Terraform outputs
      ↓
3. ArgoCD Syncs
   ├── Watches: infrastructure/kubernetes/overlays/{env}/
   ├── Renders: Kustomize/Helm with env-specific values
   └── Deploys: To namespace {env}
      ↓
4. Application Runs
   └── In Kubernetes namespace: dev/test/prod
```

---

## 📁 Complete Directory Structure

```
terraforming_again/
├── infrastructure/
│   ├── terraform/
│   │   ├── modules/              # Reusable modules
│   │   │   ├── networking/
│   │   │   ├── compute/
│   │   │   ├── database/
│   │   │   └── tailscale/
│   │   └── environments/
│   │       ├── dev/
│   │       │   ├── main.tf       # Calls modules
│   │       │   ├── variables.tf
│   │       │   ├── terraform.tfvars
│   │       │   ├── outputs.tf    # → Generates Ansible files
│   │       │   └── templates/
│   │       │       └── ansible-inventory.tpl
│   │       ├── test/             # Same structure as dev
│   │       ├── prod/             # Same structure as dev
│   │       └── shared/           # Shared variables
│   │
│   ├── ansible/
│   │   ├── inventory/
│   │   │   ├── dev/
│   │   │   │   └── hosts.yml    # ← Generated by Terraform
│   │   │   ├── test/
│   │   │   │   └── hosts.yml    # ← Generated by Terraform
│   │   │   └── prod/
│   │   │       └── hosts.yml    # ← Generated by Terraform
│   │   ├── group_vars/
│   │   │   ├── all.yml          # Common to all environments
│   │   │   ├── dev.yml          # ← Generated by Terraform
│   │   │   ├── test.yml         # ← Generated by Terraform
│   │   │   └── prod.yml         # ← Generated by Terraform
│   │   ├── playbooks/
│   │   │   ├── deploy-k8s-apps.yml    # → Deploys ArgoCD apps
│   │   │   └── site.yml
│   │   └── roles/
│   │
│   └── kubernetes/
│       ├── base/                 # Base Kubernetes manifests
│       │   ├── deployment.yaml
│       │   ├── service.yaml
│       │   ├── configmap.yaml
│       │   └── kustomization.yaml
│       └── overlays/
│           ├── dev/              # Dev-specific patches
│           │   ├── kustomization.yaml    # ← ArgoCD watches
│           │   ├── replicas-patch.yaml   # 1 replica
│           │   └── service-patch.yaml    # NodePort
│           ├── test/             # Test-specific patches
│           │   ├── kustomization.yaml    # ← ArgoCD watches
│           │   ├── replicas-patch.yaml   # 2 replicas
│           │   ├── service-patch.yaml    # LoadBalancer
│           │   └── resources-patch.yaml  # Medium resources
│           └── prod/             # Prod-specific patches
│               ├── kustomization.yaml    # ← ArgoCD watches
│               ├── replicas-patch.yaml   # 3 replicas
│               ├── service-patch.yaml    # LoadBalancer + annotations
│               ├── resources-patch.yaml  # Large resources
│               └── hpa.yaml              # Autoscaling
│
├── platform/
│   └── argocd/
│       └── applications/
│           ├── dev/
│           │   └── go-mysql-api.yaml     # ← Deployed by Ansible
│           ├── test/
│           │   └── go-mysql-api.yaml     # ← Deployed by Ansible
│           └── prod/
│               └── go-mysql-api.yaml     # ← Deployed by Ansible
│
└── .github/
    └── workflows/
        └── ci-cd-pipeline.yml    # Uses GitHub Env: dev/test/prod
```

---

## 🔄 Data Flow by Layer

### **Layer 1: Terraform (Infrastructure as Code)**

**Input:** `terraform.tfvars`
```hcl
environment = "dev"
instance_type = "t3.micro"
enable_nat_gateway = false
```

**Process:**
```bash
cd infrastructure/terraform/environments/dev
terraform workspace select dev
terraform apply
```

**Output:**
```yaml
# infrastructure/ansible/inventory/dev/hosts.yml
all:
  vars:
    environment: dev
    vpc_id: vpc-12345
    rds_endpoint: mydb.c9ac.us-east-1.rds.amazonaws.com
  children:
    dev:
      hosts:
        ec2-dev-0:
          ansible_host: 172.16.1.10
```

---

### **Layer 2: Ansible (Configuration as Code)**

**Input:** 
- `inventory/dev/hosts.yml` (from Terraform)
- `group_vars/dev.yml` (from Terraform)

**Process:**
```bash
ansible-playbook \
  -i infrastructure/ansible/inventory/dev/hosts.yml \
  -e "environment=dev" \
  infrastructure/ansible/playbooks/deploy-k8s-apps.yml
```

**Output:**
- ArgoCD Application deployed to K8s
- ConfigMap with Terraform outputs
- Secrets for database credentials

---

### **Layer 3: GitHub Actions (CI/CD Orchestration)**

**Input:** Git push to `working_branch`

**Process:**
```yaml
jobs:
  deploy-dev:
    environment: dev  # GitHub Environment
    steps:
      - terraform apply (dev)
      - ansible-playbook (dev inventory)
      - argocd app sync (dev app)
```

**Output:** Complete environment deployed

---

### **Layer 4: ArgoCD (GitOps Deployment)**

**Input:** 
- Application: `platform/argocd/applications/dev/go-mysql-api.yaml`
- Source: `infrastructure/kubernetes/overlays/dev/`

**Process:**
```yaml
ArgoCD watches: overlays/dev/
Detects changes → Syncs automatically (dev/test)
Requires manual sync (prod)
```

**Output:** Kubernetes resources in namespace `dev`

---

### **Layer 5: Kustomize (Manifest Rendering)**

**Input:**
- Base: `infrastructure/kubernetes/base/`
- Overlay: `infrastructure/kubernetes/overlays/dev/`

**Process:**
```bash
kustomize build infrastructure/kubernetes/overlays/dev/
```

**Output:**
```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: go-mysql-api
  namespace: dev
  labels:
    environment: dev
spec:
  replicas: 1  # From dev overlay
  template:
    spec:
      containers:
      - name: api
        env:
        - name: DB_HOST
          value: "mydb.c9ac.us-east-1.rds.amazonaws.com"  # From Terraform
        resources:
          requests:
            cpu: 100m   # Dev resources
            memory: 128Mi
```

---

## 🔐 IAM Role Strategy (Your Current Setup)

### **Single Role for Dev & Test:**

```
IAM Role: arn:aws:iam::690248313240:role/iacrole

Used by:
  - GitHub Actions (via OIDC)
  - Local dev (via AssumeRole with MFA)
  - Terraform (via AWS_PROFILE=dev)

Separation via:
  ✅ Terraform workspaces (dev, test, prod)
  ✅ Resource tags (Environment=dev/test/prod)
  ✅ GitHub Environment protection rules
  ✅ State file isolation
```

**GitHub Environments:**
- **dev**: Secret `AWS_ROLE_TO_ASSUME` = `...iacrole`, no protection
- **test**: Secret `AWS_ROLE_TO_ASSUME` = `...iacrole`, wait timer
- **prod**: Secret `AWS_ROLE_TO_ASSUME` = `...iacrole-prod` (different account), requires approval

---

## 📊 Environment Comparison

| Feature | Dev | Test | Prod |
|---------|-----|------|------|
| **AWS Account** | 690248313240 | 690248313240 | 987654321098 |
| **IAM Role** | iacrole | iacrole | iacrole-prod |
| **GitHub Env** | dev | test | prod |
| **Terraform Workspace** | dev | test | prod |
| **K8s Namespace** | dev | test | prod |
| **Replicas** | 1 | 2 | 3+ (HPA) |
| **Instance Type** | t3.micro | t3.small | t3.small |
| **NAT Gateway** | No (Tailscale) | Yes | Yes (Multi-AZ) |
| **RDS** | db.t3.micro | db.t3.small | db.t3.small (Multi-AZ) |
| **Service Type** | NodePort | LoadBalancer | LoadBalancer |
| **Auto-scaling** | No | No | Yes (HPA) |
| **ArgoCD Sync** | Auto | Auto | Manual |
| **Branch Restriction** | Any | main, working_branch | main only |
| **Approval Required** | No | No | Yes |
| **Monthly Cost** | ~$40 | ~$70 | ~$140 |

---

## 🚀 Usage Examples

### **Deploy Dev Environment:**

```bash
# 1. Update Terraform config
vim infrastructure/terraform/environments/dev/terraform.tfvars

# 2. Apply Terraform
cd infrastructure/terraform/environments/dev
terraform workspace select dev
terraform apply  # Generates Ansible inventory

# 3. Configure with Ansible
cd ../../../../
ansible-playbook \
  -i infrastructure/ansible/inventory/dev/hosts.yml \
  -e "environment=dev" \
  infrastructure/ansible/playbooks/deploy-k8s-apps.yml

# 4. ArgoCD auto-syncs (or manual sync)
kubectl apply -f platform/argocd/applications/dev/go-mysql-api.yaml
```

### **Or Use GitHub Actions:**

```bash
# Push to trigger workflow
git add infrastructure/terraform/environments/dev/
git commit -m "update: dev environment config"
git push origin working_branch

# GitHub Actions will:
# 1. Assume iacrole via OIDC
# 2. Run terraform apply
# 3. Generate Ansible inventory
# 4. Run Ansible playbook
# 5. Trigger ArgoCD sync
```

---

## ✅ Benefits of This Structure

1. **Single Source of Truth**: All config in Git
2. **Environment Consistency**: Same structure across dev/test/prod
3. **Automatic Propagation**: Terraform → Ansible → GitHub → ArgoCD → K8s
4. **Cost Optimized**: Different resources per environment
5. **GitOps Ready**: ArgoCD watches for changes
6. **Secure**: IAM role per environment (via GitHub Environments)
7. **Auditable**: All changes tracked in Git

---

**Your infrastructure is now fully unified across all layers!** 🎉

